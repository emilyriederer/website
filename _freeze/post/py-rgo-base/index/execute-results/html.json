{
  "hash": "24e9fc9f5c8f4d01994de67c7bf70364",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Base Python Rgonomic Patterns\"\ndescription: \"Getting comfortable in a new language is more than the packages you use. Syntactic sugar in base python increases the efficiency, and aesthetics of python code in ways that R users may seek out in packages like `glue` and `purrr`. This post demonstrates a few miscellaneous tools for date manipulation, string interpolation (f-strings), and iteration (list comprehensions)\"\nauthor: \"Emily Riederer\"\ndate: \"2024-01-20\"\ncategories: [rstats, python, tutorial]\nimage: \"featured.jpg\"\ndraft: true\n---\n\n![ Photo credit to [David Clode](https://unsplash.com/@davidclode) on Unsplash ](featured.jpg)\n\nIn the past few weeks, I've been writing about a [stack of tools](/post/py-rgo) and [specific packages like `polars`](/post/py-rgo-polars/) that may help R users feel \"at home\" when working in python due to similiar ergonomics. However, one common snag in switching languages is ramping up on common \"recipes\" for higher-level workflows (e.g. how to build a `sklearn` modeling pipeline) but missing a langugage's fundamentals that make writing glue code feel smooth (and dare I say pleasant?) It's a maddening feeling to get code for a *complex* task to finish only to have the result wrapped in an object that you can't suss out how to save or manipulate. \n\nThis post goes back to the basics. We'll briefly reflect on a few aspects of usability that have led to the success of many workflow packages in R. Then, I'll demonstrate some a grabbag of coding patterns in python that make it feel more elegant to connect bits of code into a coherent workflow. \n\nWe'll look at the kind of functinoality that you didn't know to miss until it was gone, you're may not be quite sure what to search to figure out how to get it back, *and* you wonder if it's even reasonable to hope there's an analog^[I defined this odd scope to help limit the infinite number of workflow topics that could be included like \"how to write a function\" or \"how to source code from another script\"]. This won't be anything groundbreaking -- just some nuts and bolts. Specifically: helper functions for data and time manipulation, advanced string interpolation, list comprehensions for more functional programming, and object serialization. \n\n## What other R ergonomics do we enjoy?\n\nR's passionate user and developer community has invested a lot in building tools that smooth over rough edges and provide slick, concise APIs to rote tasks. Sepcifically, a number of packages are devoted to:\n\n- **Utility functions**: Things that make it easier to \"automate the boring stuff\" like `fs` for naviating file systems or `lubridate` for more semantic date wrangling\n- **Formatting functions**: Things that help us make things look nice for users like `cli` and `glue` to improve human readability of terminal output and string interpolation\n- **Efficiency functions**: Things that help us write efficient workflows like `purrr` which provides a concise, typesafe interface for iteration\n\nAll of these capabilities are things we *could* somewhat trivially write ourselves, but we don't *want* to and we don't *need* to. Fortunately, we don't need to in python either.\n\n## Date Manipulation\n\nI don't know a data person who loves dates. In the R world, many enjoy `lubridate`'s wide range of helper functions for cleaning, formatting, and computing on dates. \n\nPython's `datetime` module is similarly effective. We can easily create and manage dates in `date` or `datetime` classes which make them easy to work with.\n\n::: {#77553842 .cell execution_count=1}\n``` {.python .cell-code}\nimport datetime\nfrom datetime import date\ntoday = date.today()\nprint(today)\ntype(today)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2024-01-18\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\ndatetime.date\n```\n:::\n:::\n\n\nTwo of the most important functions are `strftime()` and `strptime()`.\n\n`strftime()` *formats* dates into strings. It accepts both a date and the desired string format. Below, we demonstrate by commiting the cardinal sin of writing a date in non-ISO8601. \n\n::: {#fee0b784 .cell execution_count=2}\n``` {.python .cell-code}\ntoday_str = datetime.datetime.strftime(today, '%m/%d/%Y')\nprint(today_str)\ntype(today_str)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n01/18/2024\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\nstr\n```\n:::\n:::\n\n\n`strptime()` does the opposite and turns a string encoding a date into an actual date. It can try to guess the format, or we can be nice and provide it guidance.\n\n::: {#957eee77 .cell execution_count=3}\n``` {.python .cell-code}\nsomeday_dtm = datetime.datetime.strptime('2023-01-01', '%Y-%m-%d')\nprint(someday_dtm)\ntype(someday_dtm)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2023-01-01 00:00:00\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\ndatetime.datetime\n```\n:::\n:::\n\n\nDate math is also relatively easy with `datetime`. For example, you can see we calculate the date difference simply by... taking the difference! From the resulting delta object, we can access the `days` attribute.\n\n::: {#b39f1ba7 .cell execution_count=4}\n``` {.python .cell-code}\nn_days_diff = ( today - someday_dtm.date() )\nprint(n_days_diff)\ntype(n_days_diff)\ntype(n_days_diff.days)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n382 days, 0:00:00\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\nint\n```\n:::\n:::\n\n\n## String Interpolation (f-strings)\n\nR's `glue` is beloved for it's ability to easily combine variables and texts into complex strings without a lot of ugly, nested `paste()` functions.\n\npython has a number of ways of doing this, but the most readable is the newest: f-strings. Simply put an `f` before the string and put any variable names to be interpolated in `{`curly braces`}`.\n\n::: {#ca3d0221 .cell execution_count=5}\n``` {.python .cell-code}\nname = \"Emily\"\nprint(f\"This blog post is written by {name}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThis blog post is written by Emily\n```\n:::\n:::\n\n\nf-strings also support formatting with formats specified after a colon. Below, we format a long float to round to 2 digits. \n\n::: {#b4ce3c4a .cell execution_count=6}\n``` {.python .cell-code}\nproportion = 0.123456789\nprint(f\"The proportion is {proportion:.2f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe proportion is 0.12\n```\n:::\n:::\n\n\nAny python expression -- not just a single variable -- can go in curly braces. So, we can instead format that propotion as a percent. \n\n::: {#a254514f .cell execution_count=7}\n``` {.python .cell-code}\nproportion = 0.123456789\nprint(f\"The proportion is {proportion*100:.1f}%\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe proportion is 12.3%\n```\n:::\n:::\n\n\nDespite the slickness of f-strings, sometimes other string interpolation approaches can be useful. For example, if all the variables I want to interpolate are in a dictionary (as often will happen, for example, with REST API responses), the string `format()` method is a nice alternative. It allows us to pass in the dictionary, \"unpacking\" the argument with `**`^[This is called \"**kwargs\". You can read more about it [here](https://www.digitalocean.com/community/tutorials/how-to-use-args-and-kwargs-in-python-3).]\n\n::: {#84b52c0e .cell execution_count=8}\n``` {.python .cell-code}\nresult = {\n    'dog_name': 'Squeak',\n    'dog_type': 'Chihuahua'\n}\nprint(\"{dog_name} is a {dog_type}\".format(**result))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSqueak is a Chihuahua\n```\n:::\n:::\n\n\n### Application: Generating File Names\n\nCombining what we've discussed about `datetime` and f-strings, here's a pattern I use frequently. If I am logging results from a run of some script, I might save the results in a file suffixed with the run timestamp. We can generate this easily.\n\n::: {#a52bd0ae .cell execution_count=9}\n``` {.python .cell-code}\ndt_stub = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')\nfile_name = f\"output-{dt_stub}.csv\"\nprint(file_name)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\noutput-20240118_185706.csv\n```\n:::\n:::\n\n\n## Iteration\n\nThanks in part to a modern-day fiction that `for` loops in R are inefficient, R users have gravitated towards concise mapping functions for iteration. These can include the `*apply()` family^[Speaking of non-ergonomic things in R, the `*apply()` family is notoriously diverse in its number and order of arguments], `purrr`'s `map_*()` functions, or the parallelized version of either. \n\nPython too has a nice pattern for arbitrary iteration in list comprehensions. For any iterable, we can use a list comprehension to make a list of outputs by processing a list of inputs, with optional conditional and default expressions.\n\nHere are some trivial examples:\n\n::: {#af847687 .cell execution_count=10}\n``` {.python .cell-code}\nl = [1,2,3]\n[i+1 for i in l]\n[i+1 for i in l if i % 2 == 1]\n[i+1 if i % 2 == 1 else i for i in l]\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\n[2, 2, 4]\n```\n:::\n:::\n\n\nThere are also closer analogs to `purrr` like python's `map()` function. `map()` takes a function and an iterable object and applies the function to each element. Like with `purrr`, functions can be anonymous (as defined in python with lambda functions) or named. List comprehensions are popular for their concise syntax, but there are many different thoughts on the matter as expressed in [this StackOverflow post](https://stackoverflow.com/questions/1247486/list-comprehension-vs-map). \n\n::: {#dbb32199 .cell execution_count=11}\n``` {.python .cell-code}\ndef add_one(i): \n  return i+1\n\n# these are the same\nlist(map(lambda i: i+1, l))\nlist(map(add_one, l))\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\n[2, 3, 4]\n```\n:::\n:::\n\n\n### Application: Simulation\n\nAs a more realistic example, let's consider how list comprehensions might help us conduct a numerical simulation or sensitivity analysis. \n\nSuppose we want to simulate 100 draws from a Bernoulli distribution with different success probabilites and see how close our empirically calculated rate is to the true rate.\n\nWe can define the probabilites we want to simulate in a list, use a list comprehension to create the simulations. We then have a list-of-lists of results. \n\n::: {#00b7ea29 .cell execution_count=12}\n``` {.python .cell-code}\nimport numpy.random as rnd\n\nprobs = [0.1, 0.25, 0.5, 0.75, 0.9]\ncoin_flips = [ rnd.binomial(1, p, 100).tolist() for p in probs ]\nlen(coin_flips)\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\n5\n```\n:::\n:::\n\n\nTo conduct our analysis, we can put these into a `polars` dataframe.\n\n::: {#3339731f .cell execution_count=13}\n``` {.python .cell-code}\nimport polars as pl\n\ndf_flips = pl.DataFrame({'prob': probs, 'flip': coin_flips})\ndf_flips\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```{=html}\n<div><style>\n.dataframe > thead > tr,\n.dataframe > tbody > tr {\n  text-align: right;\n  white-space: pre-wrap;\n}\n</style>\n<small>shape: (5, 2)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>prob</th><th>flip</th></tr><tr><td>f64</td><td>list[i64]</td></tr></thead><tbody><tr><td>0.1</td><td>[0, 1, … 0]</td></tr><tr><td>0.25</td><td>[0, 0, … 0]</td></tr><tr><td>0.5</td><td>[0, 1, … 0]</td></tr><tr><td>0.75</td><td>[0, 1, … 0]</td></tr><tr><td>0.9</td><td>[0, 1, … 1]</td></tr></tbody></table></div>\n```\n:::\n:::\n\n\nTo analyze our data, we can then \"blow up\" our list-of-lists (going from a 5-row dataset to a 500-row dataset) and aggregate the results.\n\n::: {#f8899178 .cell execution_count=14}\n``` {.python .cell-code}\n(\ndf_flips\n  .explode('flip')\n  .group_by('prob')\n  .agg(pl.col('flip').mean().alias('p_hat'))\n  .sort('prob')\n)\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```{=html}\n<div><style>\n.dataframe > thead > tr,\n.dataframe > tbody > tr {\n  text-align: right;\n  white-space: pre-wrap;\n}\n</style>\n<small>shape: (5, 2)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>prob</th><th>p_hat</th></tr><tr><td>f64</td><td>f64</td></tr></thead><tbody><tr><td>0.1</td><td>0.08</td></tr><tr><td>0.25</td><td>0.33</td></tr><tr><td>0.5</td><td>0.6</td></tr><tr><td>0.75</td><td>0.77</td></tr><tr><td>0.9</td><td>0.86</td></tr></tbody></table></div>\n```\n:::\n:::\n\n\n## Saving In-Memory Object (Serialization)\n\nSometimes, it can be useful to save *objects* as they existed in RAM in an active programming environment. R users may have experienced this if they've used `.rds`, `.rda`, or `.Rdata` files to save individual variables or their entire environment. These objects can often be faster to reload than plaintext and can better preserve information that may be lost in other formats (e.g. storing a dataframe in a way that preserves its datatypes versus writing to a CSV file^[And yes, you can and should use Parquet and then my example falls apart -- but that's not the point!] or storing a complex object that can't be easily reduced to plaintext like a model with training data, hyperparameters, learned tree splits or weights or whatnot for future predictions.) This is called object serializaton^[And, if you want to go incredibly deep here, check out [this awesome post](https://blog.djnavarro.net/posts/2021-11-15_serialisation-with-rds/) by Danielle Navarro.]\n\nPython has comparable capabilities in the [`pickle` module](https://docs.python.org/3/library/pickle.html). There aren't really style points here, so I've not much to add beyond \"this exists\" and \"read the documentation\". But, at a high level, it looks something like this:\n\n::: {#7d0771df .cell execution_count=15}\n``` {.python .cell-code}\n# to write a pickle\nwith open('my-obj.pickle', 'wb') as handle:\n    pickle.dump(my_object, handle, protocol = pickle.HIGHEST_PROTOCOL)\n\n# to read a pickle\nmy_object = pickle.load(open('my-obj.pickle','rb'))\n```\n:::\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}